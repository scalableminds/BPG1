// Generated by CoffeeScript 1.6.2
(function() {
  var $, MARGIN, NODE_SIZE, add_vectors, collides_with, color, distance_vector, drag, draw_nodes, get_collisions, list_of_nodes, move_if_collision, move_node, overlap_position, overlap_vector, positions, reverse_vector, try_this;

  $ = jQuery;

  NODE_SIZE = 64;

  MARGIN = 5;

  list_of_nodes = [
    {
      x: 50,
      y: 30
    }, {
      x: 100,
      y: 500
    }, {
      x: 120,
      y: 300
    }, {
      x: 600,
      y: 200
    }, {
      x: 200,
      y: 90
    }, {
      x: 100,
      y: 90
    }, {
      x: 500,
      y: 50
    }, {
      x: 400,
      y: 200
    }, {
      x: 200,
      y: 600
    }, {
      x: 130,
      y: 400
    }
  ];

  color = d3.scale.category10();

  positions = {
    0: "upper_left_corner",
    1: "upper_right_corner",
    2: "bottom_left_corner",
    3: "bottom_right_corner"
  };

  $(document).ready(function() {
    return try_this();
  });

  /*
  
  Functions:
  */


  try_this = function() {
    var svg;

    svg = d3.select("body").append("svg").attr("width", 1000).attr("height", 1000).attr("id", "svg").append("g");
    return draw_nodes(svg);
  };

  collides_with = function(node, other_node) {
    return !((Math.abs(node.x - other_node.x) > NODE_SIZE) || (Math.abs(node.y - other_node.y) > NODE_SIZE));
  };

  distance_vector = function(node, other_node) {
    var x, y;

    x = other_node.x - node.x;
    y = other_node.y - node.y;
    return {
      x: x,
      y: y
    };
  };

  reverse_vector = function(vector) {
    var new_x, new_y;

    new_x = -vector.x;
    new_y = -vector.y;
    return {
      x: new_x,
      y: new_y
    };
  };

  add_vectors = function(vector, other_vector) {
    var x, y;

    x = vector.x + other_vector.x;
    y = vector.y + other_vector.y;
    return {
      x: x,
      y: y
    };
  };

  overlap_position = function(node, other_node) {
    var result;

    result = null;
    if (node.y > other_node.y) {
      if (node.x > other_node.x) {
        result = 0;
      } else {
        result = 1;
      }
    } else {
      if (node.x > other_node.x) {
        result = 2;
      } else {
        result = 3;
      }
    }
    return result;
  };

  overlap_vector = function(node, other_node, overlap_position) {
    var x, y;

    x = y = null;
    switch (overlap_position) {
      case 0:
        x = -(other_node.x + NODE_SIZE - node.x);
        y = -(other_node.y + NODE_SIZE - node.y);
        break;
      case 1:
        x = node.x + NODE_SIZE - other_node.x;
        y = -(other_node.y + NODE_SIZE - node.y);
        break;
      case 2:
        x = -(other_node.x + NODE_SIZE - node.x);
        y = node.y + NODE_SIZE - other_node.y;
        break;
      case 3:
        x = node.x + NODE_SIZE - other_node.x;
        y = node.y + NODE_SIZE - other_node.y;
    }
    return {
      x: x,
      y: y
    };
  };

  move_if_collision = function(curr_node_position, origin) {
    var coll_node, coll_node_1, coll_node_2, coll_node_3, collisions, destination_vector, dragged_node, no_collisions, overlap_pos, overlap_pos_1, overlap_pos_2, overlap_pos_3, overlap_vector_1, overlap_vector_2, overlap_vector_3, temp_1, temp_2;

    console.log("origin: ", origin);
    no_collisions = false;
    destination_vector = {
      x: 0,
      y: 0
    };
    dragged_node = curr_node_position;
    while (no_collisions === false) {
      console.log("dragged_node: ", dragged_node);
      collisions = get_collisions(curr_node_position, list_of_nodes, dragged_node);
      console.log("collisions: ", collisions);
      if (collisions.length === 0) {
        no_collisions = true;
      } else if (collisions.length === 1) {
        coll_node = collisions[0];
        overlap_pos = overlap_position(curr_node_position, coll_node);
        destination_vector = reverse_vector(overlap_vector(curr_node_position, coll_node, overlap_pos));
        destination_vector.x = destination_vector.x < 0 ? destination_vector.x - MARGIN : destination_vector.x + MARGIN;
        destination_vector.y = destination_vector.y < 0 ? destination_vector.y - MARGIN : destination_vector.y + MARGIN;
        console.log("destination_vector: ", destination_vector);
        curr_node_position = add_vectors(curr_node_position, destination_vector);
      } else if (collisions.length === 2) {
        coll_node_1 = collisions[0];
        coll_node_2 = collisions[1];
        overlap_pos_1 = overlap_position(curr_node_position, coll_node_1);
        overlap_pos_2 = overlap_position(curr_node_position, coll_node_2);
        overlap_vector_1 = overlap_vector(curr_node_position, coll_node_1, overlap_pos_1);
        overlap_vector_2 = overlap_vector(curr_node_position, coll_node_2, overlap_pos_2);
        destination_vector = reverse_vector(add_vectors(overlap_vector_1, overlap_vector_2));
        destination_vector.x = destination_vector.x < 0 ? destination_vector.x - MARGIN : destination_vector.x + MARGIN;
        destination_vector.y = destination_vector.y < 0 ? destination_vector.y - MARGIN : destination_vector.y + MARGIN;
        curr_node_position = add_vectors(curr_node_position, destination_vector);
      } else if (collisions.length === 3) {
        coll_node_1 = collisions[0];
        coll_node_2 = collisions[1];
        coll_node_3 = collisions[2];
        overlap_pos_1 = overlap_position(curr_node_position, coll_node_1);
        overlap_pos_2 = overlap_position(curr_node_position, coll_node_2);
        overlap_pos_3 = overlap_position(curr_node_position, coll_node_3);
        overlap_vector_1 = overlap_vector(curr_node_position, coll_node_1, overlap_pos_1);
        overlap_vector_2 = overlap_vector(curr_node_position, coll_node_2, overlap_pos_2);
        overlap_vector_3 = overlap_vector(curr_node_position, coll_node_3, overlap_pos_3);
        temp_1 = add_vectors(overlap_vector_1, overlap_vector_2);
        temp_2 = add_vectors(overlap_vector_2, overlap_vector_3);
        destination_vector = reverse_vector(add_vectors(temp_1, temp_2));
        destination_vector.x = destination_vector.x < 0 ? destination_vector.x - MARGIN : destination_vector.x + MARGIN;
        destination_vector.y = destination_vector.y < 0 ? destination_vector.y - MARGIN : destination_vector.y + MARGIN;
        curr_node_position = add_vectors(curr_node_position, destination_vector);
      } else {
        console.log("too many colls");
        no_collisions = true;
      }
    }
    return curr_node_position;
  };

  get_collisions = function(curr_node, other_nodes, curr_node_copy) {
    var collisions, i, node, _i, _len, _ref;

    if (curr_node_copy == null) {
      curr_node_copy = null;
    }
    collisions = [];
    _ref = _.without(other_nodes, curr_node, curr_node_copy);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      node = _ref[i];
      if (collides_with(curr_node, node)) {
        collisions.push(node);
      }
    }
    return collisions;
  };

  move_node = function(node, node_selector, destination) {
    console.log("moving node to: ", destination.x, destination.y);
    node.x = destination.x;
    node.y = destination.y;
    return d3.select(node_selector).attr({
      "transform": "translate(" + [destination.x, destination.y] + ")"
    });
  };

  drag = d3.behavior.drag().on("drag", function(d, i) {
    d.x += d3.event.dx;
    d.y += d3.event.dy;
    return d3.select(this).attr("transform", function(d, i) {
      return "translate(" + [d.x, d.y] + ")";
    });
  }).on("dragend", function(d, i) {
    var destination, node_selector;

    node_selector = "#node_" + i;
    destination = move_if_collision(d, drag.origin());
    move_node(d, node_selector, destination);
    return console.log(d);
  });

  draw_nodes = function(svg) {
    var node;

    node = svg.selectAll(".node").data(list_of_nodes).enter().append("g").attr({
      "class": "node",
      id: function(d, i) {
        return "node_" + i;
      }
    }).call(drag).attr("transform", function(d) {
      return "translate(" + d.x + "," + d.y + ")";
    });
    node.append("rect").attr({
      width: NODE_SIZE,
      height: NODE_SIZE,
      rx: 20,
      ry: 20
    }).style("fill", function(d, i) {
      return color(i % 10);
    });
    return node.append("text").attr({
      "font-size": 80
    }).attr("transform", function(d) {
      return "translate(" + d.x - NODE_SIZE + "," + d.y - NODE_SIZE + ")";
    }).text(function(d, i) {
      return i;
    });
  };

}).call(this);
