// Generated by CoffeeScript 1.6.2
/* define
d3 : d3
jquery : $
*/


(function() {
  var $, NODE_SIZE, collides_with, color, distance_vector, dragmove, draw_nodes, get_collisions, list_of_nodes, move, move_current_node, node_drag, try_this;

  $ = jQuery;

  NODE_SIZE = 64;

  list_of_nodes = [
    {
      x: 50,
      y: 30
    }, {
      x: 100,
      y: 50
    }, {
      x: 120,
      y: 30
    }, {
      x: 600,
      y: 200
    }, {
      x: 200,
      y: 90
    }, {
      x: 100,
      y: 90
    }, {
      x: 500,
      y: 50
    }, {
      x: 400,
      y: 200
    }, {
      x: 200,
      y: 30
    }, {
      x: 130,
      y: 40
    }
  ];

  color = d3.scale.category10();

  node_drag = d3.behavior.drag().on("drag", dragmove);

  $(document).ready(function() {
    return try_this();
  });

  /*
  
  Functions:
  */


  try_this = function() {
    var colls, node, node_image, svg;

    svg = d3.select("body").append("svg").attr("width", 1000).attr("height", 1000).attr("id", "svg").append("g");
    draw_nodes(svg);
    node = {
      x: 10,
      y: 20
    };
    node_image = svg.append("rect").attr({
      x: node.x,
      y: node.y,
      width: NODE_SIZE,
      height: NODE_SIZE,
      rx: 20,
      ry: 20,
      opacity: .5
    }).style({
      fill: "forestgreen",
      stroke: "red",
      "stroke-width": 5
    });
    colls = get_collisions(node, list_of_nodes);
    return console.log(colls);
  };

  collides_with = function(node, other_node) {
    console.log(Math.abs(node.x - other_node.x));
    console.log(Math.abs(node.y - other_node.y));
    if (!((Math.abs(node.x - other_node.x) > NODE_SIZE) || (Math.abs(node.y - other_node.y) > NODE_SIZE))) {
      console.log("true");
    } else {
      console.log("false");
    }
    console.log("################################");
    return !((Math.abs(node.x - other_node.x) > NODE_SIZE) || (Math.abs(node.y - other_node.y) > NODE_SIZE));
  };

  distance_vector = function(node, other_node) {
    var x, y;

    x = other_node.x - node.x;
    y = other_node.y - node.y;
    return {
      x: x,
      y: y
    };
  };

  get_collisions = function(curr_node, other_nodes) {
    var collisions, i, node, _i, _len;

    collisions = [];
    console.log(curr_node);
    for (i = _i = 0, _len = other_nodes.length; _i < _len; i = ++_i) {
      node = other_nodes[i];
      console.log(i, node);
      if (collides_with(curr_node, node)) {
        console.log("coll!!!!");
        collisions.push(node);
      }
    }
    return collisions;
  };

  move_current_node = function(curr_node, new_x, new_y) {
    curr_node.x = new_x;
    return curr_node.y = new_y;
  };

  move = function() {
    var dragTarget;

    dragTarget = d3.select(this);
    return dragTarget.attr("cx", function() {
      return d3.event.dx + parseInt(dragTarget.attr("cx"));
    }).attr("cy", function() {
      return d3.event.dy + parseInt(dragTarget.attr("cy"));
    });
  };

  dragmove = function(d, i) {
    console.log("dragging");
    d.x = d3.event.x;
    d.y = d3.event.y;
    return d3.select(this).attr("transform", function(d) {
      return "translate(" + d.x + "," + d.y + ")";
    });
  };

  draw_nodes = function(svg) {
    var node;

    console.log("drawing");
    console.log(list_of_nodes);
    node = svg.selectAll(".node").data(list_of_nodes).enter().append("g").attr("class", "node");
    node.append("rect").attr({
      x: function(d) {
        return d.x;
      },
      y: function(d) {
        return d.y;
      },
      width: NODE_SIZE,
      height: NODE_SIZE,
      rx: 20,
      ry: 20
    }).style("fill", function(d, i) {
      return color(i % 10);
    });
    return node.append("text").attr({
      "font-size": 80,
      x: function(d) {
        return d.x + NODE_SIZE / 2;
      },
      y: function(d) {
        return d.y + NODE_SIZE / 2;
      }
    }).text(function(d, i) {
      return i;
    });
  };

}).call(this);
