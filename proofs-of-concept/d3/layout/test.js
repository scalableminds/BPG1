// Generated by CoffeeScript 1.6.2
/* define
d3 : d3
jquery : $
*/


(function() {
  var $, MARGIN, NODE_SIZE, add_vectors, collides_with, color, distance_vector, drag, draw_nodes, get_collisions, list_of_nodes, move_if_collision, move_node, overlap_position, overlap_vector, positions, reverse_vector, try_this;

  $ = jQuery;

  NODE_SIZE = 64;

  MARGIN = 5;

  list_of_nodes = [
    {
      x: 50,
      y: 30
    }, {
      x: 100,
      y: 500
    }, {
      x: 120,
      y: 300
    }, {
      x: 600,
      y: 200
    }, {
      x: 200,
      y: 90
    }, {
      x: 100,
      y: 90
    }, {
      x: 500,
      y: 50
    }, {
      x: 400,
      y: 200
    }, {
      x: 200,
      y: 600
    }, {
      x: 130,
      y: 400
    }
  ];

  color = d3.scale.category10();

  positions = {
    0: "upper_left_corner",
    1: "upper_right_corner",
    2: "bottom_left_corner",
    3: "bottom_right_corner"
  };

  $(document).ready(function() {
    return try_this();
  });

  /*
  
  Functions:
  */


  try_this = function() {
    var svg;

    svg = d3.select("body").append("svg").attr("width", 1000).attr("height", 1000).attr("id", "svg").append("g");
    return draw_nodes(svg);
  };

  collides_with = function(node, other_node) {
    return !((Math.abs(node.x - other_node.x) > NODE_SIZE) || (Math.abs(node.y - other_node.y) > NODE_SIZE));
  };

  distance_vector = function(node, other_node) {
    var x, y;

    x = other_node.x - node.x;
    y = other_node.y - node.y;
    return {
      x: x,
      y: y
    };
  };

  reverse_vector = function(vector) {
    var new_x, new_y;

    new_x = -vector.x;
    new_y = -vector.y;
    return {
      x: new_x,
      y: new_y
    };
  };

  add_vectors = function(vector, other_vector) {
    var x, y;

    x = vector.x + other_vector.x;
    y = vector.y + other_vector.y;
    return {
      x: x,
      y: y
    };
  };

  overlap_position = function(node, other_node) {
    var result;

    result = null;
    if (node.y > other_node.y) {
      if (node.x > other_node.x) {
        result = 0;
      } else {
        result = 1;
      }
    } else {
      if (node.x > other_node.x) {
        result = 2;
      } else {
        result = 3;
      }
    }
    return result;
  };

  overlap_vector = function(node, other_node, overlap_position) {
    var x, y;

    x = y = null;
    switch (overlap_position) {
      case 0:
        x = -(other_node.x + NODE_SIZE - node.x);
        y = -(other_node.y + NODE_SIZE - node.y);
        break;
      case 1:
        x = node.x + NODE_SIZE - other_node.x;
        y = -(other_node.y + NODE_SIZE - node.y);
        break;
      case 2:
        x = -(other_node.x + NODE_SIZE - node.x);
        y = node.y + NODE_SIZE - other_node.y;
        break;
      case 3:
        x = node.x + NODE_SIZE - other_node.x;
        y = node.y + NODE_SIZE - other_node.y;
    }
    return {
      x: x,
      y: y
    };
  };

  move_if_collision = function(curr_node_position, curr_node_selector, origin) {
    var coll_node, coll_node_1, coll_node_2, coll_node_3, collisions, destination_vector, no_collisions, overlap_pos, overlap_pos_1, overlap_pos_2, overlap_pos_3, overlap_vector_1, overlap_vector_2, overlap_vector_3, temp_1, temp_2;

    console.log("origin: ", origin);
    no_collisions = false;
    destination_vector = {
      x: 0,
      y: 0
    };
    while (no_collisions === false) {
      collisions = get_collisions(curr_node_position, list_of_nodes);
      console.log("collisions: ", collisions);
      if (collisions.length === 0) {
        no_collisions = true;
      } else if (collisions.length === 1) {
        coll_node = collisions[0];
        overlap_pos = overlap_position(curr_node_position, coll_node);
        destination_vector = reverse_vector(overlap_vector(curr_node_position, coll_node, overlap_pos));
        destination_vector.x += MARGIN;
        destination_vector.y += MARGIN;
        curr_node_position = add_vectors(curr_node_position, destination_vector);
      } else if (collisions.length === 2) {
        coll_node_1 = collisions[0];
        coll_node_2 = collisions[1];
        overlap_pos_1 = overlap_position(curr_node_position, coll_node_1);
        overlap_pos_2 = overlap_position(curr_node_position, coll_node_2);
        overlap_vector_1 = overlap_vector(curr_node_position, coll_node_1, overlap_pos_1);
        overlap_vector_2 = overlap_vector(curr_node_position, coll_node_2, overlap_pos_2);
        destination_vector = reverse_vector(add_vectors(overlap_vector_1, overlap_vector_2));
        destination_vector.x += MARGIN;
        destination_vector.y += MARGIN;
        curr_node_position = add_vectors(curr_node_position, destination_vector);
      } else if (collisions.length === 3) {
        coll_node_1 = collisions[0];
        coll_node_2 = collisions[1];
        coll_node_3 = collisions[2];
        overlap_pos_1 = overlap_position(curr_node_position, coll_node_1);
        overlap_pos_2 = overlap_position(curr_node_position, coll_node_2);
        overlap_pos_3 = overlap_position(curr_node_position, coll_node_3);
        overlap_vector_1 = overlap_vector(curr_node_position, coll_node_1, overlap_pos_1);
        overlap_vector_2 = overlap_vector(curr_node_position, coll_node_2, overlap_pos_2);
        overlap_vector_3 = overlap_vector(curr_node_position, coll_node_3, overlap_pos_3);
        temp_1 = add_vectors(overlap_vector_1, overlap_vector_2);
        temp_2 = add_vectors(overlap_vector_2, overlap_vector_3);
        destination_vector = reverse_vector(add_vectors(temp_1, temp_2));
        destination_vector.x += MARGIN;
        destination_vector.y += MARGIN;
        curr_node_position = add_vectors(curr_node_position, destination_vector);
      } else {
        console.log("too many colls");
        no_collisions = true;
      }
    }
    return move_node(curr_node_selector, curr_node_position);
  };

  get_collisions = function(curr_node, other_nodes) {
    var collisions, i, node, _i, _len;

    collisions = [];
    for (i = _i = 0, _len = other_nodes.length; _i < _len; i = ++_i) {
      node = other_nodes[i];
      if (node !== curr_node) {
        if (collides_with(curr_node, node)) {
          collisions.push(node);
        }
      }
    }
    return collisions;
  };

  move_node = function(node_selector, destination) {
    return console.log("moving node to: ", destination.x, destination.y);
  };

  /*
  
  # drag.on(type, listener)
  
  Registers the specified listener to receive events of the specified type from the drag behavior. The following events are supported:
  
  "dragstart": fired when a drag gesture is started.
  "drag": fired when the element is dragged. d3.event will contain "x" and "y" properties representing the current absolute drag coordinates of the element. It will also contain "dx" and "dy" properties representing the element's coordinates relative to its position at the beginning of the gesture.
  "dragend": fired when the drag gesture has finished.
  # drag.origin([origin])
  
  If origin is specified, sets the origin accessor to the specified function. If origin is not specified, returns the current origin accessor which defaults to null.
  */


  drag = d3.behavior.drag().on("drag", function(d, i) {
    d.x += d3.event.dx;
    d.y += d3.event.dy;
    return d3.select(this).attr("transform", function(d, i) {
      return "translate(" + [d.x, d.y] + ")";
    });
  }).on("dragend", function(d, i) {
    var node_selector;

    node_selector = "#node_" + i;
    move_if_collision(d, node_selector, drag.origin());
    return console.log(d);
  });

  draw_nodes = function(svg) {
    var node;

    node = svg.selectAll(".node").data(list_of_nodes).enter().append("g").attr({
      "class": "node",
      id: function(d, i) {
        return "node_" + i;
      }
    }).call(drag).attr("transform", function(d) {
      return "translate(" + d.x + "," + d.y + ")";
    });
    node.append("rect").attr({
      width: NODE_SIZE,
      height: NODE_SIZE,
      rx: 20,
      ry: 20
    }).style("fill", function(d, i) {
      return color(i % 10);
    });
    return node.append("text").attr({
      "font-size": 80
    }).attr("transform", function(d) {
      return "translate(" + d.x - NODE_SIZE + "," + d.y - NODE_SIZE + ")";
    }).text(function(d, i) {
      return i;
    });
  };

}).call(this);
