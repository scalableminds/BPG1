// Generated by CoffeeScript 1.6.2
(function() {
  var $, MARGIN, NODE_SIZE, add_vectors, collides_with, color, distance_vector, drag, draw_nodes, get_collisions, list_of_nodes, move_if_collision, move_node, overlap_vector, reverse_vector, subtract_vectors, try_this, version;

  $ = jQuery;

  version = 2;

  NODE_SIZE = 64;

  MARGIN = 5;

  list_of_nodes = [
    {
      x: 50,
      y: 30
    }, {
      x: 100,
      y: 500
    }, {
      x: 120,
      y: 300
    }, {
      x: 600,
      y: 200
    }, {
      x: 200,
      y: 90
    }, {
      x: 100,
      y: 90
    }, {
      x: 500,
      y: 50
    }, {
      x: 400,
      y: 200
    }, {
      x: 200,
      y: 600
    }, {
      x: 130,
      y: 400
    }
  ];

  color = d3.scale.category10();

  $(document).ready(function() {
    return try_this();
  });

  /*
  
  Functions:
  */


  try_this = function() {
    var svg;

    svg = d3.select("body").append("svg").attr("width", 1000).attr("height", 1000).attr("id", "svg").append("g");
    return draw_nodes(svg);
  };

  collides_with = function(node, other_node) {
    return !((Math.abs(node.x - other_node.x) > NODE_SIZE) || (Math.abs(node.y - other_node.y) > NODE_SIZE));
  };

  distance_vector = function(node, other_node) {
    var x, y;

    x = other_node.x - node.x;
    y = other_node.y - node.y;
    return {
      x: x,
      y: y
    };
  };

  reverse_vector = function(vector) {
    var new_x, new_y;

    new_x = -vector.x;
    new_y = -vector.y;
    return {
      x: new_x,
      y: new_y
    };
  };

  add_vectors = function(vector, other_vector) {
    var x, y;

    x = vector.x + other_vector.x;
    y = vector.y + other_vector.y;
    return {
      x: x,
      y: y
    };
  };

  subtract_vectors = function(vector, other_vector) {
    var x, y;

    x = vector.x - other_vector.x;
    y = vector.y - other_vector.y;
    return {
      x: x,
      y: y
    };
  };

  overlap_vector = function(node, other_node) {
    var temp, x, y;

    temp = subtract_vectors(node, other_node);
    x = temp.x < 0 ? temp.x + NODE_SIZE : temp.x - NODE_SIZE;
    y = temp.y < 0 ? temp.y + NODE_SIZE : temp.y - NODE_SIZE;
    return {
      x: x,
      y: y
    };
  };

  move_if_collision = function(curr_node_position, origin) {
    var coll_node, collisions, destination_vector, dragged_node, loop_iterations, no_collisions, overlap_vec, reversed_dest_vector, _i, _len;

    no_collisions = false;
    destination_vector = {
      x: 0,
      y: 0
    };
    dragged_node = curr_node_position;
    loop_iterations = 0;
    while ((no_collisions === false) && (loop_iterations < 100)) {
      collisions = get_collisions(curr_node_position, list_of_nodes, dragged_node);
      if (collisions.length === 0) {
        no_collisions = true;
      } else if (collisions.length >= 4) {
        no_collisions = true;
      } else {
        reversed_dest_vector = {
          x: 0,
          y: 0
        };
        for (_i = 0, _len = collisions.length; _i < _len; _i++) {
          coll_node = collisions[_i];
          overlap_vec = overlap_vector(curr_node_position, coll_node);
          reversed_dest_vector = add_vectors(reversed_dest_vector, overlap_vec);
        }
        destination_vector = reverse_vector(reversed_dest_vector);
        destination_vector.x = destination_vector.x < 0 ? destination_vector.x - MARGIN : destination_vector.x + MARGIN;
        destination_vector.y = destination_vector.y < 0 ? destination_vector.y - MARGIN : destination_vector.y + MARGIN;
        curr_node_position = add_vectors(curr_node_position, destination_vector);
        loop_iterations += 1;
      }
    }
    return curr_node_position;
  };

  get_collisions = function(curr_node, other_nodes, curr_node_copy) {
    var collisions, i, node, _i, _len, _ref;

    if (curr_node_copy == null) {
      curr_node_copy = null;
    }
    collisions = [];
    _ref = _.without(other_nodes, curr_node, curr_node_copy);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      node = _ref[i];
      if (collides_with(curr_node, node)) {
        collisions.push(node);
      }
    }
    return collisions;
  };

  move_node = function(node, node_selector, destination) {
    node.x = destination.x;
    node.y = destination.y;
    return d3.select(node_selector).attr({
      "transform": "translate(" + [destination.x, destination.y] + ")"
    });
  };

  drag = d3.behavior.drag().on("dragstart", function(d, i) {
    return this.copy = _.clone(d);
  }).on("drag", function(d, i) {
    if (version === 2) {
      this.copy.x += d3.event.dx;
      this.copy.y += d3.event.dy;
      if (get_collisions(this.copy, _.without(list_of_nodes, d)).length === 0) {
        d3.select(this).attr("transform", function(d, i) {
          return "translate(" + [d.x, d.y] + ")";
        });
        d.x = this.copy.x;
        d.y = this.copy.y;
        return this.copy = _.clone(d);
      }
    } else {
      d.x += d3.event.dx;
      d.y += d3.event.dy;
      return d3.select(this).attr("transform", function(d, i) {
        return "translate(" + [d.x, d.y] + ")";
      });
    }
  }).on("dragend", function(d, i) {
    var destination, node_selector;

    if (version === 1) {
      node_selector = "#node_" + i;
      destination = move_if_collision(d, drag.origin());
      return move_node(d, node_selector, destination);
    }
  });

  draw_nodes = function(svg) {
    var node;

    node = svg.selectAll(".node").data(list_of_nodes).enter().append("g").attr({
      "class": "node",
      id: function(d, i) {
        return "node_" + i;
      }
    }).call(drag).attr("transform", function(d) {
      return "translate(" + d.x + "," + d.y + ")";
    });
    node.append("rect").attr({
      width: NODE_SIZE,
      height: NODE_SIZE
    }).style("fill", function(d, i) {
      return color(i % 10);
    });
    return node.append("text").attr({
      "font-size": 80
    }).attr("transform", function(d) {
      return "translate(" + d.x - NODE_SIZE + "," + d.y - NODE_SIZE + ")";
    }).text(function(d, i) {
      return i;
    });
  };

}).call(this);
